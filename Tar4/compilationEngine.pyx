# Gets its input from a Jackinput_file, and emits its output to an output file

# The output is generated by a series of compilexxx routines,
# structured according to the grammar rules that define xxx

# Each compilexxx routine is responsible for handling all the tokens that make up 
#xxx, advancing the input_file exactly beyond these tokens, and outputing the parsing of xxx.

# Thus, compilexxx may only be called if indeed xxx is the next thing in the input.

cdef class CompilationEngine:
    cdef input_file
    cdef output_file
    cdef int indent
    cdef str next_token
    
    # Constructor
    def __cinit__(self, input_file, output_file):
        self.output_file = output_file
        self.indent = 0
        self.input_file = open(input_file, 'r')
        self.getNextToken() # read  <tokens>

        self.compileClass()

    #Get the next token from the input
    def getNextToken(self):
        return self.input_file.readline().strip()
            
    # Compiles a complete class
    cdef compileClass(self):
        self.output_file.write('<class>\n')
        self.indent += 1
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read class
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read class name
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read {
        self.compileClassVarDec()
        self.compileSubroutine()
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read }
        self.indent -= 1
        self.output_file.write('</class>\n')
        self.output_file.close()

    # Compiles a static declaration or a field declaration
    cdef compileClassVarDec(self):
        # if the next token is not static or field then return
        self.next_token = self.getNextToken()
        if self.next_token != "<keyword> static </keyword>" and self.next_token != "<keyword> field </keyword>":
            return
        self.output_file.write(self.indent * '  ' + '<classVarDec>\n')
        self.indent += 1
        # if the next token is static or field
        self.output_file.write(self.indent * '  ' +  self.next_token + '\n') # read static or field
        self.output_file.write(self.indent * '  ' +  self.getNextToken() + '\n') # read type
        self.output_file.write(self.indent * '  ' +  self.getNextToken() + '\n') # read varName
        # while the next token is a comma
        self.next_token = self.getNextToken() # read ',' or ';'
        while self.next_token == ',':  # read ,
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
            self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read varName
            self.next_token = self.getNextToken() # read ',' or ';'
        self.output_file.write(self.indent * '  ' + self.next_token) # read ;
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</classVarDec>\n')

    # Compiles a complete method, function, or constructor
    cdef compileSubroutine(self):
        cdef temp
        # if the next token is not a constructor, function, or method then return
        if self.next_token == "<keyword> constructor </keyword>" or self.next_token == "<keyword> function </keyword>" or self.next_token == "<keyword> method </keyword>":
            temp = self.next_token
        else:
            temp = self.getNextToken() # read constructor, function, or method
        self.output_file.write(self.indent * '  ' + '<subroutineDec>\n')
        self.indent += 1
        # if the next token is a constructor, function, or method
        self.output_file.write(self.indent * '  ' + temp + '\n')
        # if the next token is void or a type
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read void or type
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read subroutineName
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read (
        self.compileParameterList()
        if self.next_token == "<symbol> ) </symbol>":
            temp = self.next_token
        else:
            temp = self.getNextToken() # read )
        self.output_file.write(self.indent * '  ' + temp + '\n')
        self.compileSubroutineBody()
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</subroutineDec>\n')

    # Compiles a (possibly empty) parameter list, not including the enclosing “()”
    cdef compileParameterList(self):
        self.output_file.write(self.indent * '  ' + '<parameterList>\n')
        self.next_token = self.getNextToken()
        # if the next token is a type
        if self.next_token != "<symbol> ) </symbol>":
            self.indent += 1
            self.output_file.write(self.indent * '  ' +  self.next_token + '\n') # read type
            self.output_file.write(self.indent * '  ' +  self.getNextToken() + '\n') # read varName
            # while the next token is a comma
            self.next_token = self.getNextToken()
            while self.next_token == ',':  # read ,
                self.output_file.write(self.indent * '  ' + '<symbol> , </symbol>\n')
                self.output_file.write(self.indent * '  ' +  self.getNextToken() + '\n') # read type
                self.output_file.write(self.indent * '  ' +  self.getNextToken() + '\n') # read varName
                self.next_token = self.getNextToken() # read ',' or ')'
            self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</parameterList>\n')

    # Compiles a subroutine's body
    cdef compileSubroutineBody(self):
        self.output_file.write(self.indent * '  ' + '<subroutineBody>\n')
        self.indent += 1
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read {
        self.compileVarDec()
        self.compileStatements()
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read }
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</subroutineBody>\n')

    # Compiles a var declaration
    cdef compileVarDec(self):
        # if the next token is not var then return
        self.next_token = self.getNextToken()
        if self.next_token != "<keyword> var </keyword>":
            return
        self.output_file.write(self.indent * '  ' + '<varDec>\n')
        self.indent += 1
        # if the next token is var
        self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read var
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read type
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read varName
        # while the next token is a comma
        self.next_token = self.getNextToken() # read ',' or ';'
        while self.next_token == "<symbol> , </symbol>": # read ,
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
            self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read varName
            self.next_token = self.getNextToken() # read ',' or ';'
        self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read ;
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</varDec>\n')
        self.compileVarDec()

    # Compiles a sequence of statements, not including the enclosing “{}”
    cdef compileStatements(self):
        self.output_file.write(self.indent * '  ' + '<statements>\n')
        self.indent += 1
        # while the next token is a statement
        while self.next_token == "<keyword> let </keyword>" or self.next_token == "<keyword> if </keyword>" or self.next_token == "<keyword> while </keyword>" or self.next_token == "<keyword> do </keyword>" or self.next_token == "<keyword> return </keyword>":
            if self.next_token == "<keyword> let </keyword>":
                self.compileLet()
            elif self.next_token == "<keyword> if </keyword>":
                self.compileIf()
            elif self.next_token == "<keyword> while </keyword>":
                self.compileWhile()
            elif self.next_token == "<keyword> do </keyword>":
                self.compileDo()
            elif self.next_token == "<keyword> return </keyword>":
                self.compileReturn()
            self.next_token = self.getNextToken()
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</statements>\n')

    # Compiles a do statement
    cdef compileDo(self):
        self.output_file.write(self.indent * '  ' + '<doStatement>\n')
        self.indent += 1
        self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read do
        self.compileSubroutineCall()
        self.output_file.write(self.indent * '  ' + '<symbol> ; </symbol>\n') # read ;
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</doStatement>\n')
        
    # Compiles a let statement
    cdef compileLet(self):
        self.output_file.write(self.indent * '  ' + '<letStatement>\n')
        self.indent += 1
        self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read let
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read varName
        # if the next token is [
        self.next_token = self.getNextToken()
        if self.next_token == "<symbol> [ </symbol>":
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
            self.compileExpression()
            self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read ]
        self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read =
        self.compileExpression()
        self.output_file.write(self.indent * '  ' + '<symbol> ; </symbol>\n')
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</letStatement>\n')

    # Compiles a while statement
    cdef compileWhile(self):
        self.output_file.write(self.indent * '  ' + '<whileStatement>\n')
        self.indent += 1
        self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read while
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read (
        self.compileExpression()
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read )
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read {
        self.compileStatements()
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read }
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</whileStatement>\n')

    # Compiles a return statement
    cdef compileReturn(self):
        self.output_file.write(self.indent * '  ' + '<returnStatement>\n')
        self.indent += 1
        self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read return
        # if the next token is not ;
        self.next_token = self.getNextToken()
        if self.next_token != "<symbol> ; </symbol>":
            self.compileExpression()
        self.output_file.write(self.indent * '  ' + '<symbol> ; </symbol>\n')
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</returnStatement>\n')

    # Compiles an if statement, possibly with a trailing else clause
    cdef compileIf(self):
        self.output_file.write(self.indent * '  ' + '<ifStatement>\n')
        self.indent += 1
        self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read if
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read (
        self.compileExpression()
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read )
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read {
        self.compileStatements()
        self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read }
        # if the next token is else
        if self.getNextToken() == "<keyword> else </keyword>":
            self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read else
            self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read {
            self.compileStatements()
            self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read }
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</ifStatement>\n')

    # Compiles an expression
    cdef compileExpression(self):
        self.output_file.write(self.indent * '  ' + '<expression>\n')
        self.indent += 1
        self.compileTerm()
        # while the next token is an operator or ;
        while self.next_token == '+' or self.next_token == '-' or self.next_token == '*' or self.next_token == '/' or self.next_token == '&' or self.next_token == '|' or self.next_token == '<' or self.next_token == '>' or self.next_token == '=':
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
            self.compileTerm()
            self.next_token = self.getNextToken() # read an operator or ;
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</expression>\n')

    # Compiles a term.  If the current token is an identifier, the routine must distinguish between a variable, an array entry, and a subroutine call.  A single look-ahead token, which may be one of "[", "(", or "." suffices to distinguish between the possibilities.  Any other token is not part of this term and should not be advanced over.
    cdef compileTerm(self):
        self.output_file.write(self.indent * '  ' + '<term>\n')
        self.indent += 1
        # if the next token is an integer constant
        self.next_token = self.getNextToken() # read integer constant, string constant, keyword constant, identifier, unary operator, (, or subroutine call
        if self.next_token[:8] == "<integer":
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
        # if the next token is a string constant
        elif self.next_token[:7] == "<string":
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
        # if the next token is a keyword constant
        elif self.next_token == "<keyword> true </keyword>" or self.next_token == "<keyword> false </keyword>" or self.next_token == "<keyword> null </keyword>" or self.next_token == "<keyword> this </keyword>":
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
        # if the next token is an identifier
        elif self.next_token[:12] == "<identifier>":
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
            # if the next token is [ or .
            self.next_token = self.getNextToken() # read [ or . or ( or an operator or ;
            if self.next_token == "<symbol> [ </symbol>":
                self.output_file.write(self.indent * '  ' + self.next_token + '\n')
                self.compileExpression()
                self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read ]
            elif self.next_token == "<symbol> . </symbol>": # read . subroutineName or ( expressionList )
                self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read .
                self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read subroutineName
                self.output_file.write(self.indent * '  ' + self.getNextToken() + '\n') # read (
                self.compileExpressionList()
                self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read )
        # if the next token is a unary operator
        elif self.next_token == '-' or self.next_token == '~':
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
            self.compileTerm()
        # if the next token is (
        elif self.next_token == "<symbol> ( </symbol>":
            self.output_file.write(self.indent * '  ' + self.next_token + '\n')
            self.compileExpression()
            self.output_file.write(self.indent * '  ' + self.next_token + '\n') # read )
        self.next_token = self.getNextToken() # read an operator or ;
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</term>\n')

    # Compiles a (possibly empty) comma-separated list of expressions
    cdef compileExpressionList(self):
        self.output_file.write(self.indent * '  ' + '<expressionList>\n')
        self.indent += 1
        # if the next token is an expression
        if self.next_token != "<symbol> ) </symbol>":
            self.compileExpression()
            # while the next token is a comma
            while self.next_token == ',':  # read ,
                self.output_file.write(self.indent * '  ' + self.next_token + '\n')
                self.compileExpression()
                if self.next_token == "<symbol> ) </symbol>":
                    break
                self.next_token = self.getNextToken() # read ',' or ')'
        self.indent -= 1
        self.output_file.write(self.indent * '  ' + '</expressionList>\n')


